## Учебная практика
____
Программа предназначена для ~~чтения текста~~ считывания текста на кириллице. На вход требуется подать файл расширения .txt, после чего он будет обработан программой. На вывод также подается файл .txt. Программа способна обрабатывать любой текст с любым количеством символов от 3000 до 15000 элементов уж тем более, время сортировки зависит от количества элементов, счиытваемых из файла. Притом в файле могут находиться как символы криллицы, так и числовые значения вместе с символами других алфовитов, это не является проблемой, так как лишние символы будут выведены в соответствующую строку по окончании работы программы, как и числовые значения. Сортировка выполняется при помощи метода быстрой сортировки, который невероятно хорошо справляется с задачей **быстрой сортировки**, для выполнения сортировки массива используется данная функция:
``` C++
void sort(string* S, int N) //функция быстрой сортировки массива строк
{
    int i = 0, j = N; //Указатели в начало и в конец массива
    string mid;
    mid = S[N/2]; //Центральный элемент массива
    //Делим массив
    do
    {
        while (S[i] < mid) i++;//Пробегаем элементы, ищем те, которые нужно перекинуть в другую часть
        //В левой части массива пропускаем(оставляем на месте) элементы, которые меньше центрального
        while (S[j] > mid) j--;//В правой части пропускаем элементы, которые больше центрального
        if (i <= j)
        {
            //Меняем элементы местами
            swap(S[i], S[j]);
            i++;
            j--;
        }
    } while (i <= j);
    //Рекурсивные вызовы, если осталось, что сортировать
    if (j > 0) sort(S, j);//"Левый кусок"
    if (N > i) sort(S + i, N - i);//"Првый кусок"
}
```
:white_check_mark:Функция принимает на вход динамический массив типа string, в котором записаны все слова из файла в нижнем регистре, готовые к сортировке. Также на вход поступает переменная N – количество слов в массиве. Создаем две переменные – i=0 и j=N. Также создаем переменную mid = S[N/2], она указывает на центральный элемент в массиве S. После идут два цикла, которые ищут элементы, которые нужно перекинуть в другую часть массива. Если элемент левой стороны меньше центрального, то мы пропускаем его, если больше, то при помощи функции swap меняем местами с элементом, найденным с правой стороны. Эти действия повторяются до тех пор, пока i <= j, невыполнение этого условия будет означать, что не все элементы рассмотрены. После выхода из этого цикла при условии, что j > 0 снова вызывается функция sort (S,j), теперь уже N является не общим количеством слов массиве, а только примерно половиной. Таким образом эта функция будет вызываться снова и снова, беря всё меньшие и меньшие куски массива для сортировки, пока массив не будет полностью отсортирован. Те же действия выполняются и для правой части массива при помощи условия N > i и вызова рекурсивной функции с значениями sort(S + i, N - i). Таким образом мы получаем на выходе полностью отсортированный динамический массив типа string.

**Очень важно**, чтобы на вход подавался файл именно формата .txt!
![image](https://user-images.githubusercontent.com/106414534/171769335-3e95030a-b3b4-494c-9ff6-84d7c7467d08.png)
